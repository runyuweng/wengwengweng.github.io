<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Weng&#39;s Blog</title>
  <meta name="author" content="Weng">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Weng&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Weng&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Weng&#39;s Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-03-10T16:00:00.000Z"><a href="/2017/03/11/2017-03-11-manifest/">2017-03-11</a></time>
      
      
  
    <h1 class="title"><a href="/2017/03/11/2017-03-11-manifest/">缓存</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="一、mainfest"><a href="#一、mainfest" class="headerlink" title="一、mainfest"></a>一、mainfest</h2><h3 id="缓存文件："><a href="#缓存文件：" class="headerlink" title="缓存文件："></a>缓存文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"># 7de115d4f9748943ec2f</div><div class="line"></div><div class="line">common.js</div><div class="line">index.js</div><div class="line">index.css</div><div class="line"></div><div class="line">CACHE:</div><div class="line">common.js</div><div class="line">index.js</div><div class="line">index.css</div><div class="line"></div><div class="line">NETWORK:</div><div class="line">*</div><div class="line"></div><div class="line">SETTINGS:</div><div class="line">prefer-online</div></pre></td></tr></table></figure>
<h3 id="生成manifest"><a href="#生成manifest" class="headerlink" title="生成manifest"></a>生成manifest</h3><p>使用一旦修改代码，打包时自动更新混存清单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var AppCachePlugin = require(&apos;appcache-webpack-plugin&apos;);</div><div class="line">webpackConfig.plugins.push(</div><div class="line">  new AppCachePlugin(&#123;</div><div class="line">    cache: [</div><div class="line">      &apos;common.js&apos;,</div><div class="line">      &apos;index.js&apos;,</div><div class="line">      &apos;index.css&apos;,</div><div class="line">    ],</div><div class="line">    network: [&apos;*&apos;],  // No network access allowed!</div><div class="line">    //fallback: [&apos;index.html&apos;],</div><div class="line">    settings: [&apos;prefer-online&apos;],</div><div class="line">    //exclude: [],  // Exclude file.txt and all .js files</div><div class="line">    output: &apos;appcache.manifest&apos;</div><div class="line">  &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="缓存前后时间对比"><a href="#缓存前后时间对比" class="headerlink" title="缓存前后时间对比"></a>缓存前后时间对比</h3><table>
<thead>
<tr>
<th></th>
<th>缓存前</th>
<th>缓存后</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total</td>
<td>3.80s</td>
<td>1.82s</td>
</tr>
<tr>
<td>Loading</td>
<td>50.9ms</td>
<td>21.4ms</td>
</tr>
<tr>
<td>Scripting</td>
<td>1390.7ms</td>
<td>764.9ms</td>
</tr>
<tr>
<td>Rendering</td>
<td>168.6ms</td>
<td>54.7ms</td>
</tr>
<tr>
<td>Painting</td>
<td>36.6ms</td>
<td>12.5ms</td>
</tr>
<tr>
<td>Other</td>
<td>307.1ms</td>
<td>109.3ms</td>
</tr>
<tr>
<td>Idle</td>
<td>1843.1ms</td>
<td>856.9ms</td>
</tr>
</tbody>
</table>
<ul>
<li>Idle: 浏览器等待时间</li>
</ul>
<h2 id="二、HTTP"><a href="#二、HTTP" class="headerlink" title="二、HTTP"></a>二、HTTP</h2><h3 id="304"><a href="#304" class="headerlink" title="304"></a>304</h3><p>解释:<br>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</p>
<h2 id="三、H5技术缓存"><a href="#三、H5技术缓存" class="headerlink" title="三、H5技术缓存"></a>三、H5技术缓存</h2><h3 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h3><h3 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h3>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-02-27T16:00:00.000Z"><a href="/2017/02/28/2017-02-28-js-this/">2017-02-28</a></time>
      
      
  
    <h1 class="title"><a href="/2017/02/28/2017-02-28-js-this/">关于js中的this</a></h1>
  

    </header>
    <div class="entry">
      
        <p>网上this的指向很多都是说指向引用他的对象，<br>其实this的指向因根据不同情况而定。</p>
<h2 id="一、在函数中调用"><a href="#一、在函数中调用" class="headerlink" title="一、在函数中调用"></a>一、在函数中调用</h2><p>首先思考为啥下面这块代码的输出是什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  var a = 1;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">test();//undefined</div></pre></td></tr></table></figure></p>
<p>这个代码块的输出又是什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function test()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">test();//1</div></pre></td></tr></table></figure></p>
<p>由此可见函数中的this指的是全局对象。</p>
<h2 id="二、作为对象的方法调用"><a href="#二、作为对象的方法调用" class="headerlink" title="二、作为对象的方法调用"></a>二、作为对象的方法调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var dog = &#123;</div><div class="line">  name:&quot;D&quot;,</div><div class="line">  sayName:function()&#123;</div><div class="line">    console.log(`Hi,i&apos;m $&#123;this.name&#125;.`);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">dog.sayName();//Hi,i&apos;m D.</div></pre></td></tr></table></figure>
<p>当this作为对象的方法调用时this指向该对象。</p>
<h2 id="三、作为构造函数调用"><a href="#三、作为构造函数调用" class="headerlink" title="三、作为构造函数调用"></a>三、作为构造函数调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  this.a = 1;</div><div class="line">&#125;</div><div class="line">var b = new test();</div><div class="line">console.log(b.a);//1</div></pre></td></tr></table></figure>
<p>作为构造函数调用时，this指向new出的对象。</p>
<h2 id="四、通过使用apply或call等方法后"><a href="#四、通过使用apply或call等方法后" class="headerlink" title="四、通过使用apply或call等方法后"></a>四、通过使用apply或call等方法后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">  a:1</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">  a:2</div><div class="line">&#125;</div><div class="line">function test()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">obj1.f = test;</div><div class="line">obj1.f.apply(obj2);//2</div><div class="line">obj1.f.call(obj2);//2</div></pre></td></tr></table></figure>
<p>apply()是函数对象的一个方法，<br>它的作用是改变函数的调用对象，<br>它的第一个参数就表示改变后的调用这个函数的对象。<br>因此当使用apply或call改变调用对象后this指的就是这第一个参数。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-01-22T16:00:00.000Z"><a href="/2017/01/23/2017-01-23-react-lifecycle/">2017-01-23</a></time>
      
      
  
    <h1 class="title"><a href="/2017/01/23/2017-01-23-react-lifecycle/">react生命周期</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文是对react官网内容的<code>翻译</code>并加入了一些自己的<code>理解</code>包括一些简单的react<code>优化</code>方法。  </p>
<p>react的生命周期主要分为三个大的阶段，<br>每个阶段又分若干个小方法。<br>带有will前缀的方法指在事件发生前调用，<br>而带有did前缀的方法指在事件发生后调用。  </p>
<p>具体流程图如下：  </p>
<p><img src="../img/lifecycle.jpg" alt=""></p>
<h2 id="1-Mounting-–-装载"><a href="#1-Mounting-–-装载" class="headerlink" title="1. Mounting – 装载"></a>1. Mounting – 装载</h2><h3 id="1-1-componentWillMount"><a href="#1-1-componentWillMount" class="headerlink" title="1.1 componentWillMount"></a>1.1 componentWillMount</h3><p>在render方法前执行一次，<br>不管state是否改变都只执行一次，<br>在此方法中调用setState方法在render中将获取到state的更新变化，<br>此方法可以在服务器端和客户端被调用。</p>
<h3 id="1-2-componentDidMount"><a href="#1-2-componentDidMount" class="headerlink" title="1.2 componentDidMount"></a>1.2 componentDidMount</h3><p>在render方法执行后执行一次，<br>并且与componentWillMount方法一样只执行一次，<br>不同的是此方法只能在客户端被调用。<br>你可以在这个方法中访问基本DOM结构因为此时已渲染出真是DOM，<br>一般在此方法中向服务器请求数据。<br>需要注意的是子组件的compontentDidMount方法会在父组件的之前调用。<br>⚠️假设这样一个情景：<br>子组件需要拿到父组件的一些state才能继续加载，<br>而父组件的这些state需要向服务器发送请求才能拿到，<br>上述加载顺序必定会引发子组件无法正常加载的情况，<br>面对这种情况该如何解决？</p>
<h2 id="2-Updating-–-更新"><a href="#2-Updating-–-更新" class="headerlink" title="2. Updating – 更新"></a>2. Updating – 更新</h2><h3 id="2-1-componentWillReceiveProps"><a href="#2-1-componentWillReceiveProps" class="headerlink" title="2.1 componentWillReceiveProps"></a>2.1 componentWillReceiveProps</h3><p>当组件接收到新的props调用此方法，<br>在初始渲染时不调用，<br>可以在这个方法里更新state,<br>以触发render方法重新渲染组件。<br>该方法可与条件判断语句一起使用来解决</p>
<blockquote>
<p>子组件的compontentDidMount方法会在父组件的之前调用</p>
</blockquote>
<p>的问题。  </p>
<p>⚠️注意：在此函数中调用this.props获取的是老的props。</p>
<h3 id="2-2-shouldComponentUpdate"><a href="#2-2-shouldComponentUpdate" class="headerlink" title="2.2 shouldComponentUpdate"></a>2.2 shouldComponentUpdate</h3><p>当接收到新的props或state时在render前调用，<br>对于初次渲染和forceUpdate不调用此方法，<br>当该方法返回false跳过render方法和之后的componentWillUpdate和componentDidUpdate方法。<br>当然该方法默认返回值为true。<br>⚠️注意：当组件数量较大时可以使用该方法来进行性能的优化。</p>
<h3 id="2-3-componentWillUpdate"><a href="#2-3-componentWillUpdate" class="headerlink" title="2.3 componentWillUpdate"></a>2.3 componentWillUpdate</h3><p>该方法在render方法前被立即调用，<br>并且对于初次渲染不调用此方法。<br>⚠️注意：你不能在此方法中调用setState()方法，<br>若需要应在componentWillReceiveProps方法中。</p>
<h3 id="2-4-componentDidUpdate"><a href="#2-4-componentDidUpdate" class="headerlink" title="2.4 componentDidUpdate"></a>2.4 componentDidUpdate</h3><p>该方法在render方法后被立即调用，<br>并且对于初次渲染不调用此方法，<br>当组件更新时，这是操作DOM的好机会。</p>
<h2 id="3-Unmounting-–-卸载"><a href="#3-Unmounting-–-卸载" class="headerlink" title="3. Unmounting – 卸载"></a>3. Unmounting – 卸载</h2><h3 id="3-1-componentWillUnmount"><a href="#3-1-componentWillUnmount" class="headerlink" title="3.1 componentWillUnmount"></a>3.1 componentWillUnmount</h3><p>在组件将从DOM被卸载时立即调用，<br>主要用来执行一些必要的清理任务。<br>例如清除setTimeout等函数，<br>或者任意的在componentDidMount创建的DOM元素。</p>
<h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4. 优化方案"></a>4. 优化方案</h2>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-01-17T16:00:00.000Z"><a href="/2017/01/18/2017-01-18-js-data-type/">2017-01-18</a></time>
      
      
  
    <h1 class="title"><a href="/2017/01/18/2017-01-18-js-data-type/">JS数据类型</a></h1>
  

    </header>
    <div class="entry">
      
        <p>首先来看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原始类型</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'Hi'</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line">b = b + <span class="string">'weng'</span>;</div><div class="line"><span class="built_in">console</span>.log(a === b);  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">//引用类型</span></div><div class="line"><span class="keyword">var</span> c = [<span class="string">'Hi'</span>, <span class="string">'weng'</span>];</div><div class="line"><span class="keyword">var</span> d = c;</div><div class="line">d.push(<span class="string">'!'</span>);</div><div class="line"><span class="built_in">console</span>.log(c === d); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>由此可以引出原始类型数据和引用类型数据的定义：</p>
<blockquote>
<p>原始类型：保存为简单的数据值。<br>引用类型：保存为对象，其本质是指向内存位置的引用。</p>
</blockquote>
<p>这就不难解释为什么上述代码输出的分别是<code>false</code>和<code>true</code>了，<br>在第二个小例子中<code>c</code>和<code>d</code>同时指向一个内存位置，<br>所有把他们做比较返回的是<code>true</code>。</p>
<h2 id="1-原始类型"><a href="#1-原始类型" class="headerlink" title="1.原始类型"></a>1.原始类型</h2><p>js有五种原始类型：</p>
<ul>
<li>boolean，布尔类型，值为<code>true</code> 或<code>false</code></li>
<li>number，数字类型，值为数字（包括整形和浮点型）</li>
<li>string，字符串类型，值为字符串（用引号括住）</li>
<li>null，空类型，值为<code>null</code></li>
<li>undefined，未定义类型，值为<code>undefined</code>  </li>
</ul>
<p>鉴别原始类型可以使用<code>typeof</code>方法，除了<code>null</code>，当使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>会输出”object”,因此当检验<code>null</code>时可以使用”===”。</p>
<h2 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h2><p>引用类型有哪些呢？简单来说就是除了上述五种基本类型之外的类型。<br>其实可以统称为<code>对象</code>，对象是包含属性的无序列表，而属性是包含键（key）和值（value）。<br>如果一个属性的值为函数，即可称他为<code>方法</code>。</p>
<h3 id="2-1对象实例化"><a href="#2-1对象实例化" class="headerlink" title="2.1对象实例化"></a>2.1对象实例化</h3><p>大家应该都清楚，一般对象如何实例化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()；</div><div class="line">obj.a = <span class="string">"a"</span>； <span class="comment">//为其添加属性</span></div><div class="line">obj = <span class="literal">null</span>； <span class="comment">//不适用对象时对其引用进行解除，释放内存</span></div></pre></td></tr></table></figure></p>
<h3 id="2-2如何鉴别引用类型"><a href="#2-2如何鉴别引用类型" class="headerlink" title="2.2如何鉴别引用类型"></a>2.2如何鉴别引用类型</h3><p>function可使用typeof方法来鉴别，<br>而其他引用类型则需要使用instanceof方法了，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="2-3原始封装类型"><a href="#2-3原始封装类型" class="headerlink" title="2.3原始封装类型"></a>2.3原始封装类型</h3><p>下面再来看一段代码，js刚刚接触的同学可能就会产生疑惑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> firstChar = str.charAt(<span class="number">0</span>)  <span class="comment">//H</span></div></pre></td></tr></table></figure></p>
<p>为什么原始类型的数据也会有方法可以调用呢？<br>其实js引擎在背后做了这些事：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(str);</div><div class="line"><span class="keyword">var</span> firstChar = temp.charAt(<span class="number">0</span>);</div><div class="line">temp = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>这里的<code>String</code>就是原始封装类型，<br>原始封装类型还有<code>Number</code>和<code>Boolean</code>,<br>由于第二行把字符串当作对象使用，<br>所以js引擎创建了字符串的实体以让其工作。  </p>
<p>js基础的东西还有很多，一时也写不出个完全，在以后的文章里会慢慢记录感悟。</p>
<p>（完）</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/web/">web</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Weng
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
